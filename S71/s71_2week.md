# 디자인패턴

DP CATEGORY (디자인패턴 카테고리)

생성패턴 -

구조패턴 - 객체 관계 지어 문제를 풀자 객체끼리 알아두기

행동패턴 - 어떤 식으로 행동해서 푸는가

이미 객체지향설계에 숙달한 살마을 대상으로 함
잘하는 사람 입장에 분류대로 사용하면 좋다.
우리한테는 해당 없다.

객제지향설계를 학습할 수 있는 분류

다형성 - 대체 가능성, 자식 대신 부모. 부모 자리에 자식이. 내적동질성(생략)

캡슐화 - 어떤 복잡한 기능을 직접 외부에 노출하지 않고 쉬운 기능(표현하고 싶은 기능)
        ATM 돈을 인출 외부에 노출은 인출 실제로는 내 은행 계좌 확인 거래 시간 확인 합당한 권한 있는지 (신불, 범죄자) 인출 요청 승인 내 ATM기 현금 있는지
        하지만 사람들에겐 인출!

        외부에 노출되고 싶은것만 하는게 캡슐
        행동을 추상화

        은닉은 직접적인 노출을 싫어한다.

객체 간 관계 - 문제 해결시 객체끼리 관련된 객체망 형성 객체가 망을 형성할때 망을 만든다.(부모 자식, 데이터와 렌더러 계약관계 렌더러에게 메세지를 넘기면)
            소유 관계 - 할일 하나하나 태스크 실제로 할일 전체 관리하는건 태스크 매니져

변화율 - 어떤 식으로 객체를 설계하는지 조직화 하는지. 변화율 역할모델(저번시간 동시 반영). 어떤건 자주 바뀌고 어떤건 자주 안바뀜 부모 자식간 분류하는 경우가 많다. 데이터라는건 결국 외부에 인포 반영. 이 책임은 1년이 지나도 안바뀜 제이슨데이터는 제이슨으로부터 데이터를 만든 책임을 가짐. 같은 카테고리안에서.

역할모델 - 수정해야 되는 건수들을. 렌더러와 데이터 분류 데이터 공급하는 건수 데이터에서 처리. 그림은 렌더러쪽에서 처리

객체 설계 배우기 힘든 이유 2개 동시에 반영하기 때문

근본적인 문제는 알고리즘
컴파일시 2진수 직렬로 컴파일로 한다. 컴퓨터는 알고리즘으로 문제를 푼다. 알고리즘은 상태와 분기에 대한 내용이다.

---

ALGORITHM PATTERN
2가지 종류
제어문과 상태를 조절

제어문 : 조건문, 반복문
오늘 대부분은 조건문을 해결하는 패턴(다음 시간은 반복문)

상태 :
기존 제어문 기반의 알고리즘이 갖는 문제
"수정하면 전체가 컴파일 됨"

자바스크립트는 컴파일 안쓴다.(중요하지 않다.)
정의시점, 실행시점으로 나눈다.
함수 생성시 함수 호출시보다 생성을 정의 시점. 호출하는걸 실행시점이라고 할수 있다. 상대적인것.
OS-정의시점 브라우져-실행시점
브라우저-정의시점 자바스크립트는 브라우저의 정의되어잇는것을 가지고 실행시점을

컴파일 됨 = 정의시점이 된다.
구구단 만드는 함수 코드 확정후 호출하면 실행
10단까지할때는 함수 수정해야된다. 수정시 모든 의존되는것들 여파 다 확인해야 한다.
안고치는게 최고다.

격리 이론 : 안고칠려고. 최대한 안고친다. 필요한것만 고친다.
이 정책에는 제어문하고 연관된 알고리즘은 위배된다.
제어문 기반의 알고리즘은 나쁘다!
알고리즘이 변화한 부분만 수정하고 나머지는 건드리고 싶지 않다면?
최대한 개별 알고리즘을 함수로 분리한다.

---

알고리즘이 변화는 이유는? (야 놀자 방값이 변활때 3% ~ 5% 얼리버드시 추가 할인 10%)
비지니스 변화
연관라이브러리 변화 - jQuery 변화, 외부 API는 통제할 수 없다.
호스트측 변화 - 쓰는쪽의 사정 우리가 API설꼐했는데 브라우저에서 쓰는걸로 .. 환경 변화. 감당할수 없는 것들을 수용하는 입장
따라서 대부분 통제불가요소

``` js
//공통부분 미리처리 부분
if(case == 1) {
  case1();
}else if(case == 2) {
  case2();
}lese if(case == 3) {
  case3();
}
//공통부분 미리처리 부분
```

계약 관계 성립 상태 공유 하지 않을꺼야 독립적으로 해. 리턴값을 받는다면 그 함수는 리턴값을 줘야돼.

지금은 개별 함수만 잘 검사하면 된다. 여파가 줄었다.

각 경우별 변화는 개별함수만 변경하면 됨.
문제는 경우가 변경될 때!
case4번 등장시 코드를 건든다.

코드 의존 하는 여파를 모두 고려하고 테스트 해야 된다. 저장하는 순간 모든것들은 다 검사해야 된다. 그 전과 다른 코드다.
우린 사람이다. 모두 다 테스트. 여파가 최소화하고 싶게 한다.

케이스가 들어갈 경우 감단 안된다.

``` js
위에꺼랑 어짐
const case 1 = _ => {
  //공통부분
  //case1전용
};
const case2 =_=> {
  //공통부분
  //case1전용
};
```

코드 중복되었을때
코드 중복있는 코드는 안된다.
수정사항오면 수정 반복을 할 수 없다. 100% 에러난다.
어디까지 집착해서 중복코드를 보느냐가 문제. 다 제거해라.

개별 함수 내부에 공통부분이 발생하는 경우
분기 전후에 공통부분 미리 처리

알고리즘 분화 시 객체지향에서 선택할 수 있는 두가지 방법

상속 위임 - 내부계약관계로 추상층에서 공통 요소를 해결하고 상태를 공유하고 있음
아들이 있는데 아빠가 그 가게가서 결제했어 먹는건 알아서 먹어(위임)
부모가 할일은 부모가 하고 나머지는 자식이 한다.
추상층(부모) 공통 요소 해결!
상태 공유 중요하다.
상점에가서 커피를 사서 티켓(상태))을 아들에게 준다.
공통요소, 상태공유

소유 위임 - 외부계약관계로 각각ㄱ이 독립적인 문제를 해결하며 메세지를 주고 받는 것으로 문제를 해결함.
데이터와 렌더러와 관계 값으로 계약하면 안좋다.
info같은 메서드 객체 존재
상속 위임보다 더 복잡하다.
외부관계이기때문에 깔금 오직 프로토콜 독릭접인 문제 해결
메세지를 주고 받는다(프로토콜로) 상태를 메세지안에 포함된다. 공유하지 않는다.
데이터가 렌더러한테 줄때 인포로 준다.
데이터 내부의 속성 끄내는 건 JSON데이터

GoF DP 방향상 - 소유 위임

상속 위임은 부모가 1개라서 나머지 문제 해결 못하는 양산 가능성 존재
소유 위임도 1개의 1개만 처리한다. 여러개 처리하면 단일체계 위배..

상속 위임은 변화율에 대응(끈적끈적)하고 쉽고 소유 위임은 수정하는 역할모델에 적합(남남)

상속위임
Service 클래스
type에 따라 json을 검사한다. 테이터별로 벨리에팅션 따로따로 멤버 노티스일때 따로따로 분기해줬다.멤버일땐 언더체크멤버, 노시트일땐 언더체크노티스 문제없으면 리턴되고 아니면 쓰로우
부모자식간에 상태 공유하니깐 인자 보내지 않는다. 상태 잡아준다. 상속관꼐는 상태를 공유한다.

날리지
서비스가 가지고 있는 지식중에 타입에 대한 지식이 많다. 부모가 다 가지고 있따. 타입에 대한 지식은 부모가 소유한다.
추상 부모니깐 언더체크멤버, 언더체크노티스 쓰로우

자식 체크 서비스1은 언더 2개 만들어 작동시킨다.

1. 정의시점 공통 부분
체크1, 체크2 공통적으로 소유할때는 공통적으로 처리한다.

2. 실행시점 위임부분
스위치 타입 케이스 왜 실행시점 위임부분?
실제 사용될때는 자식클래스에껄로 연결된다. 실행시점이 자식
겟데이터가 호출 되는 시점에서 어떤 자식이 바인딩되는것이 중요하다.
서비스 정의하는 시점에 잇는 메소드가 아니고 정의되고 난 이후에 이거 다 한 이후에 실행된다.

3. 실행시점에 위임된 알고리즘
자식 클래스 실행시점 이후에 부모의 알고리즘을 포함할려고. 바뀐 함수만큰 객체를 만들어 대응 가능. A함수 건들이기. 외부에 자식을 새롭게 만들면 된다. A함수 그대로 두고
일종의 상태 보존이 된다.
이제는 아무것도 안건들이고 서비스 2를 만든다.

위에 다 템플릿 메소드 패턴 TEMPLATE METHOD PATTERN
상속 위임을 통해 알고리즘을 처리한다.

나머지 변화되지 않을 얘들을 건들지 않고 세이브하지않고 처리하게 된다.
객체지향, 디자인패턴 같이 배우면 효과적
겟데이터 템플릿 메소드
공통 부분을 처리하는 부분도 잇고
실행 시점 위임된 부분을 템플릿이라고 한다.

나머지 디자인 패턴은 소유 위임을 지향
이것만 상속 위임 지향

객체지향 설계에 익숙해진 사람들이기때문에 상속위임을 잘 쓰겠지하고 전제로 해서 없는것 뿐이다. 객체 상속이 객체 설계망에서 빠지는것이 아니다.

실행시점 위임
<script src=""></script>
<script></script>
<script></script>
정의 시점 확정

실행시점은
<script>
Serviceservice
</script>

정의시점을 안건들이고 실행시점에서 알고리즘을 바꿀 수 있다.
정의시점 다음에 나오는게 실행시점

서비스를(쩡의시점) 기준으로 서비스1,2가 실행시점

---

상속 위임 - > 소유 위임

소유위임
자식이 없으니깐 내 알고리즘 받아줄 얘를 외부에서 계약 맺는다.(인자 1개 체커) 체커랑 계약
this._json 상태 공유 안되니깐 잡으면 안된다._

외부계약자의 메서드를 통해 외부계약에게 위임
소유위임

실행시점 위임 객체(디스.체커=체커); 체커 정의될때 존재(인자)
실행시점 외부계약을 통한 위임

외부계약자 전략객체
콘스트 체커
멤버 (제이슨)
노티스(제이슨))

알고리즘 일부는 위임해준다.
상속위임보다 들 끈적끈쩍 extends가 없다. 굉장히 독립적이다.
체커에 여러가지 자식들 만들수 있따. 체커 사정
서비스랑은 상관없다. 노티스랑 멤버만 제공하면

실행시점 위임

s서비스.js
체커
체커1 - 정의시점
체커2 - 정의시점

<script> 실행시점
서비스1
서비스2
</script>
각각 계약자가 공급해주는 알고리즘이 다르다.
다양ㅇ한 전략 선택 가능 체커1, 체커2 동작이 다르다.

호스트 코드가 안바껴도 알고리즘 공급자가 바끼면 코드가 바뀐다.
호스트코드가 같은 로직 쓰고. 코드 안건들이게 장땡.
뉴 체커1, 뉴체커2만 바꿔도 코드를 바꿀수있다.

---

각 경우별 변화는 개별함수만 변경하면 됨
"문제는 경우가 변경될때" -> "포괄적 위임"()

이프는 고정되고 이프 안에있는것들 수정하고 싶을때

타입의 데한 지식 탬플릿 메서드 패턴 서비스가 가지고 있다.
이제는 그 지식을 계속 서비스가 가지고 있으면 케이스를 늘릴 수 없다.
타입에 대한 지식도 자식에게 포괄적으로 위임

상속 위임 - 포괄적 위임
타입에 대한 지식을 포기하고 (자기가 타임을 권한을 포기)
타입을 상태공유로 위임
아들이 대학교 들어가면 그렇게 된다. 논다. 포괄위임

코드가 구상으로 이전되었을 뿐 정의시점 코드에 경우는 고정됨
자식에게 부담됨 타입에 대한 지식 소유하니깐

문제는 지식을 이사 필요한 점은 어디가지 않았다. 자식 하나 더 만들면 복사되서 또 간다.
복사되면 무조건 에러.

구상층 = 자식

템플릿 메서드 패턴 한계 - 이미 경우가 확정되었을때 사용 가능
탬플릿이 확정 되었을때만 사용 가능

소유 위임 -
케이스를 늘리고 싶다. 마음대로
멤버, 노티스 케이스
케이스가 정해져 있지 않다. 이 뜻은 케이스가 배열이거나 오브젝트로 되어 있다는 형태. 케이스가 정해지지 않았고 적재
new Map(); 케이스를 적재.
체커가 똑같이 형인지 외부계약이니깐 맺어야 된다. 소유 위임은 무조건 외부 계약.
맵에다 해당 타입과 체커를 넣어준다. 케이스의 수가 가변적으로 변한다.

실행시점에 타입이 있는지 체크한다. 실행시점평가.
최대한 실행 시점에 결정되는건 실행시점에서 평가. 겟데이터 부르기전에만.. 있으면 괜찮고 없으면 노 체커. 체커의 해당 체커를 읽어와서 개한테 체크시켜주면 된다.
아예 케이스가 없다 동적으로 해결되니깐.

케이스를 담는 구조체를 라우팅 테이블
라우터 동적으로 케이스를 결정할수 있는 구조체..??
라우팅 테이블 작성해서 처리하는.. 라우팅

라우팅을 통해서 실행시점 전략객체 위임

공부는 용어를 아는게 전부다.!

es6구문에서 익명 클래스 처럼 간이 인터페이스 제공한다. 생성자에서 함수 하나 받아들이고 바깥에 노출..

서비스.js - 정의시점
체커.js - 정의시점 ( 간이 인터페이스 )

script
/script

M도우미 함수 mandatory 필수

서비스에 애드체커 2개 썻다. 멤버 어드민
케이스를 더 늘리고 싶어요 여기서 대응하면 된다. 실행시점에서 대응(정의서점아니고)

간이인터페이스 마커 인터페이스
{} 오브젝트 리터럴, 지역벼수와 키 이름 일치하면

기본값이 인자들은 뒤에 쓴다.
이제 파싱할때 순서를 보장한다. 네임, 닉네임 옵션

라우팅 테이블2개잇으니깐 라우터.

실행시점에 경우가 추가됨.
