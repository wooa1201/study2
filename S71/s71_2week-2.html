<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>S72-2</title>
</head>
<body>
  <script type="text/javascript">
    /*
      참조와 값을 발견
      참조는 메모리 주소만 알고 있다. 실제 주소는 1개인데 많이 안다.

      값은 이곳 저곳 복사

      배열은 참조고 3은 값이야
      자바스크립트 문자열은 값인데 자바는 참조야

      값과 참조는 언어가 정한다

      참조로 인식되면 메모리상 1개고 나타나면 주소값만
      값은 다른얘한테 참조하면 복사 복사

      참조 얘뜰은 메모리안 주소만 알려줘서 경계면을 넘기 힘들다.
      클라이언트, 서버 사이
      제이슨을 넘기는것을 실패

      참조를 값으로 바꿔야 넘어갈 수 있다.
      서버에서 넘어갈때도 값으로 온것을 참조로 바꿔야 한다.

      참조값이 경계면을 넘어갈 수 없기 때문이다.
      윈도우 포스트? 웹 워커 참조 값은 경계면을 넘어가지 못한다.
      로컬 스트러지, 쿠키

      참조 -> 값 , 값 -> 참조 이렇게 해야 경계면을 넘어간다.

      숫자가 64비트 넘어가거나 문자가 더럽게 클때
      네이티브 객체를 못 넣는다.
      로컬 스토리지에 넣을 수 없다.

    */

    /*let a = {
      v: 3
    };*/
    let a = {
      v: {v : 3}
    };
    // 자바스크립트 참조로 인식하는 a 만듬

    let b = a;
    // 연결된 포인터라는 개념이 없다. a와 b는 같은 참조값을 가질꺼야.
    /*a = {
      v: 5
    };*/
    a.v = { v: 5};
    //b.v; // 3 연결이 끊어짐. 동일한 참조를 갖지 않게 된다. 잘못된 코드
    b.v.v // 5

    // 이 코드의 문제점 b가 3이 나오면 문제. 코드의 의도 늬앙스와 의미가 있다.
    // 연결된 포인트가 없으니까 한놈이 배신때리면 나머지는 망가짐.
    // 참조와 값이 있따. 참조는 배신을 때린다.
    // b와 a의 계약 b가 a를 따른다. 보스를 따른다.
    // 해결 못한다. 인정. a가 진짜로 활동할때 참조를 바꾸면 안된다.
    /*
      링크드 리스트, 부모와 자식
    */

    const Parent = class {
      method() {
        this._method();
      }
      _method(){
        console.log("Parent")
      }
    };

    const Child = class extends Parent {
      _method() {
        console.log('Child');
      }
    };
    (new Parent).method(); // 인자 없는 클래스 () 생략 가능 Parent
    (new Child).method(); // Child
    console.log(new Child instanceof Parent); // true 나는 자식이지만 부모이기도 해

    /*
      이름이 가리키는게 함수 위치
      나한테 없는건 부모꺼를 찾는다.(method)
      포인터의 위치를 메소드 이름으로 계약
      동적으로 연결된 포인터의 위치를 마킹

      객체지향에서 대체가능성이 가능한 이유
      부모와 자식간의 포인터공유가 가능하기 떄문에

      method() {
        this._method();
      }
      Child가 this._method();
      내적 동질성
      내부에서 니가 한번 차일드면 너는 끝까지 차일드야. 넌 차일드로 태어났어.
      this는 Parent일때 Parent, Child일때 Child

      태어날떄부터 아이덴티티가 정해진다.
      있으면 지꺼 먼저 내적동질성 떄문에
      없으면 부모꺼 찾는다. 쭉쭉 찾는다.(대체가능성)
    */

    /*
      링크드 리스트
      다음 로드에 있는 메소드 포인터
    */
  </script>
</body>
</html>
