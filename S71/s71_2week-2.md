상태에 대한 분기는 사라지지 않는다.
그 분기가 필요해서 태어났기 때문
-> 정의 시점에 제거하는 방법은?
1. 분기 수 만큼 객체를 만들고
2. 실행시점에 경위 수를 공급

조건문은 절대로 사라지지 않는다. 필요해서 태어났으니깐 if가 필요하니깐 태어났다. 필요하지 않은 if는 오류.
이번 시즌 얼리버드 5% 애가 있으면, 필요해서 태어났다.
우리가 할 수 잇는일은 옮기는 것밖에 안된다.

변화가 일어나지 않을꺼면 통짜로 짜도 상관 없다. 하지만 변화하므로 if문을 통짜로 짜면 다 수정해야된다. 그럼 오류

2개만큼 객체 만든다 케이스
실행시점에 경우의 수를 공금 이러므로서 서비를 안 건들일 수 있다.

실행시점으로 분기르 옮길 때의 장단점
장점 : 일정한 통베 점위 내에서 확장가능한 알고리즘설계 가능
1. 정의 시점에 모든 경우를 몰라도 된다.
    아예 모른다. 장기적인 업데이트의 유리하다. 알피지기 게임 무기 100종 서비그 끝날때까지 마지막일까? 무기 나올때마다 스위치문 컴파일
    지금은 라우팅 테이블에만 있는것들만 컴파일 모든 경우의 수... 전략패턴

2. 정의 시점에 그 경우를 처리하는 방법도 몰라도됨.
    무기의 공격효과 방어력하고 체력으로 계싼했다가 게임 업데이트후 마법 이펙트 방어구 동료의 힐링 스탯 반영하면 무기의 효과 달라지도록
    나중에 그 스탯을 인지해서
    알고리즘 확장이 자유롭다.
    알고리즘 분기 제어 상태 제어. 일단 만들 수 있다.
    어택이라는 메소드를 무기 1개만 가지고도 나중에 무기도 추가 가능.

단점 : 매 호스트코드마다 안정성을 따로 담보해야함
1. 실행 시점에 모든 경우를 반드시 기술해야 함.
    정의 시점에 노티스, 멤버 확실히 기술..?
    실행 시점마다 알고리즘 실행 보장
    이 시점에 원하는게 준비 안될수도있따. 런타임때마다
    각각 스크립트 마지막 코드 환경때마다 바꿔줘야 된다.
    기존에는 1군데였지만 개별 호스트코드를 봐야 된다.

2. 실행 시점마다 알고리즘의 안정성을 담보해야함.

패턴은 패턴으로 덮는다.

캡슐화 패턴 FACTORY, BUILDER PATTERN

지식으로 저희한테 까놔서 우리가

ATM기 인출만하고 싶은데 인출의 대한 내용을 다 까발렸다.  캡슐화를 해야겠다.
유연성을 얻기 위해 전략 패턴 사용했더니 내장이 다 빠져나옸다 이걸 캡슐화로 덮는다.

생성 레시피 캡슐화
M은 필요하다. 이제 다 지식, 날리지, 레시피 동의어 특정 도메인에 대한
레시피 타입에 대한 조직, 마지막 라우팅 테이블 애드체커...
빌더 패턴
외부에 인터페이스로 겟서비스 베이스 유알엘 마크업 인터페이스

구상객체 = 자식
멤버서비스빌더 = 서비스빌더 상속
겟서비스를 제공할 책임이 있다.
암묵적 내부계약 베이스 유알엘받아와서 책임이 잇다.(안받음)

서비스를 만들어서 = 뉴 서비스
서비스에다 전략 패턴 애드 체커
거기에 대한 모든 지식은 애가 가진다.
우아하게 서비스만 얻는다.
멤버서비스빌더의 서비스를 얻는다. 타입으로 서비스지만 평범한 레시피가 아니다.

애드체커 2개 넣는거 멤버, 조인
서비스에 유연성으로 전략패턴
호스트코드는 빌더패턴

정의시점

사용시점

비지니스 도메인이 반영된 서비스를 갖는다.

어떤 빌더로부터 어떤 겟서비스를사용하는거부터..
정의시점으로 올라갔다.
호스트코드는 안정적으로 사용할 수 있다.

디자인 패턴으 하나하나 단계적으로 배울수 없다. 하나의 문제를 해결하면 다른 문제가 나타난다. 그래서 다른 패턴으로 덮는다.

알고리즘의 미래의 유연성을 달성 그러면 다른 여파 또다른 패턴이 막는다.
연쇄패턴 일어난다. 디자인 패턴 자체가 함정. 패턴 함정 패턴 함정 ~~
균형적인 패턴 조합

컴포넌트 패턴 (MVC패턴 옵저버패턴) 더이상 패턴이 증식하지 않는다. 5~6개 패턴 이용

단일 패턴은 다른 여파를 만들어 낸다. 잘 섞으면 서로의 여파를 상쇄시킨다.

궁극적인 지향점은 컴포넌트 패턴이다.
